#!/usr/bin/env python3
"""
obs-turbo - Unified observability CLI for abemon.es

Quick access to Grafana/Loki logs and Uptime Kuma status for Claude Code agents.

Usage:
    obs-turbo logs <service> [--last DURATION] [--grep PATTERN] [--error] [--json]
    obs-turbo tail <service> [--filter PATTERN]
    obs-turbo status [service]
    obs-turbo services
    obs-turbo labels
    obs-turbo query <logql>

Examples:
    obs-turbo logs abemon.es --last 1h
    obs-turbo logs abemon.es --error --last 24h
    obs-turbo logs all --grep "500" --last 6h
    obs-turbo tail bm.consulting --filter error
    obs-turbo status
    obs-turbo status abemon.es
    obs-turbo services

Duration formats: 5m, 1h, 24h, 7d (minutes, hours, days)
"""

import sys
import os
import json
import argparse
import requests
import re
from datetime import datetime
from typing import Dict, List, Optional, Any

# Config
CREDS_FILE = os.path.expanduser("~/.obs_credentials.json")

# Service aliases (friendly name -> Loki project label)
SERVICE_ALIASES = {
    "abemon": "abemon.es",
    "bm": "BM Consulting",
    "bm.consulting": "BM Consulting",
    "codex": "codex.abemon.es",
    "foodplan": "foodplan.pro",
    "logistics": "Logistics Express",
    "blue-mountain": "blue-mountain.es",
    "trafico": "trafico-dashboard",
    "app-logistics": "app.logisticsexpress.es",
    "z-logistics": "z.logisticsexpress.es",
    "cifex": "CIFex",
}


class ObsError(Exception):
    """Observability CLI error."""
    pass


def load_credentials() -> Dict[str, Any]:
    """Load credentials from config file."""
    if not os.path.exists(CREDS_FILE):
        raise ObsError(f"Credentials file not found: {CREDS_FILE}")

    with open(CREDS_FILE) as f:
        return json.load(f)


def parse_duration(duration: str) -> int:
    """Parse duration string to nanoseconds for Loki."""
    match = re.match(r'^(\d+)([mhd])$', duration.lower())
    if not match:
        raise ObsError(f"Invalid duration format: {duration}. Use 5m, 1h, 24h, 7d")

    value = int(match.group(1))
    unit = match.group(2)

    if unit == 'm':
        return value * 60 * 1_000_000_000
    elif unit == 'h':
        return value * 3600 * 1_000_000_000
    elif unit == 'd':
        return value * 86400 * 1_000_000_000

    return value * 1_000_000_000


def resolve_service(service: str) -> Optional[str]:
    """Resolve service alias to Loki project label."""
    if service.lower() == "all":
        return None  # No filter
    return SERVICE_ALIASES.get(service.lower(), service)


def query_loki(creds: Dict, logql: str, limit: int = 1000, start_ns: int = None, end_ns: int = None) -> List[Dict]:
    """Query Loki via Grafana proxy."""
    grafana_url = creds["grafana"]["url"]
    token = creds["grafana"]["token"]

    url = f"{grafana_url}/api/datasources/proxy/uid/loki/loki/api/v1/query_range"

    now = int(datetime.now().timestamp() * 1_000_000_000)
    if end_ns is None:
        end_ns = now
    if start_ns is None:
        start_ns = now - (3600 * 1_000_000_000)  # Default 1h

    params = {
        "query": logql,
        "limit": limit,
        "start": start_ns,
        "end": end_ns,
        "direction": "backward",
    }

    headers = {"Authorization": f"Bearer {token}"}

    try:
        resp = requests.get(url, params=params, headers=headers, timeout=30)
        resp.raise_for_status()
        data = resp.json()

        if data.get("status") != "success":
            raise ObsError(f"Loki query failed: {data}")

        return data.get("data", {}).get("result", [])
    except requests.exceptions.RequestException as e:
        raise ObsError(f"Loki request failed: {e}")


def get_labels(creds: Dict) -> List[str]:
    """Get available Loki labels."""
    grafana_url = creds["grafana"]["url"]
    token = creds["grafana"]["token"]

    url = f"{grafana_url}/api/datasources/proxy/uid/loki/loki/api/v1/labels"
    headers = {"Authorization": f"Bearer {token}"}

    resp = requests.get(url, headers=headers, timeout=10)
    resp.raise_for_status()
    data = resp.json()

    return data.get("data", [])


def get_label_values(creds: Dict, label: str) -> List[str]:
    """Get values for a specific label."""
    grafana_url = creds["grafana"]["url"]
    token = creds["grafana"]["token"]

    url = f"{grafana_url}/api/datasources/proxy/uid/loki/loki/api/v1/label/{label}/values"
    headers = {"Authorization": f"Bearer {token}"}

    resp = requests.get(url, headers=headers, timeout=10)
    resp.raise_for_status()
    data = resp.json()

    return data.get("data", [])


def cmd_logs(args):
    """Query logs from Loki."""
    creds = load_credentials()

    service = resolve_service(args.service)

    if service:
        # Match by project label (exact match)
        logql = f'{{project="{service}"}}'
    else:
        logql = '{project=~".+"}'  # All projects

    # Add grep filter (case-insensitive)
    if args.grep:
        logql += f' |~ "(?i){args.grep}"'

    # Add error filter (case-insensitive)
    if args.error:
        logql += ' |~ "(?i)(error|exception|fatal|panic|critical)"'

    # Parse duration
    duration_ns = parse_duration(args.last)
    now = int(datetime.now().timestamp() * 1_000_000_000)
    start_ns = now - duration_ns

    # Query
    results = query_loki(creds, logql, limit=args.limit, start_ns=start_ns, end_ns=now)

    if args.json:
        # Output as JSON for agents
        output = []
        for stream in results:
            labels = stream.get("stream", {})
            for ts, line in stream.get("values", []):
                output.append({
                    "timestamp": datetime.fromtimestamp(int(ts) / 1_000_000_000).isoformat(),
                    "project": labels.get("project", ""),
                    "service": labels.get("service_name", labels.get("service", "")),
                    "message": line
                })
        print(json.dumps(output, indent=2))
    else:
        # Human-readable output
        if not results:
            print(f"No logs found for {args.service} in the last {args.last}")
            return

        all_lines = []
        for stream in results:
            for ts, line in stream.get("values", []):
                labels = stream.get("stream", {})
                dt = datetime.fromtimestamp(int(ts) / 1_000_000_000)
                project = labels.get("project", "?")
                service_name = labels.get("service_name", labels.get("service", "?"))
                all_lines.append((int(ts), dt, project, service_name, line))

        # Sort by timestamp (oldest first for readability)
        all_lines.sort(key=lambda x: x[0])

        for ts, dt, project, service_name, line in all_lines:
            time_str = dt.strftime("%H:%M:%S")
            # Truncate long lines
            if len(line) > 200:
                line = line[:197] + "..."
            print(f"{time_str} [{project}] {line}")


def cmd_tail(args):
    """Stream logs in real-time (polls every 2s)."""
    import time

    creds = load_credentials()
    service = resolve_service(args.service)

    if service:
        logql = f'{{project="{service}"}}'
    else:
        logql = '{project=~".+"}'

    if args.filter:
        logql += f' |~ "(?i){args.filter}"'

    print(f"Tailing logs for {args.service}... (Ctrl+C to stop)")
    print("-" * 60)

    seen_timestamps = set()

    try:
        while True:
            now = int(datetime.now().timestamp() * 1_000_000_000)
            start_ns = now - (10 * 1_000_000_000)  # Last 10 seconds

            results = query_loki(creds, logql, limit=100, start_ns=start_ns, end_ns=now)

            new_lines = []
            for stream in results:
                labels = stream.get("stream", {})
                for ts, line in stream.get("values", []):
                    if ts not in seen_timestamps:
                        seen_timestamps.add(ts)
                        dt = datetime.fromtimestamp(int(ts) / 1_000_000_000)
                        project = labels.get("project", "?")
                        new_lines.append((int(ts), dt, project, line))

            # Print new lines (sorted by time)
            new_lines.sort(key=lambda x: x[0])
            for ts, dt, project, line in new_lines:
                time_str = dt.strftime("%H:%M:%S")
                if len(line) > 200:
                    line = line[:197] + "..."
                print(f"{time_str} [{project}] {line}")

            # Clean up old timestamps to prevent memory growth
            if len(seen_timestamps) > 10000:
                cutoff = now - (60 * 1_000_000_000)
                seen_timestamps = {ts for ts in seen_timestamps if int(ts) > cutoff}

            time.sleep(2)
    except KeyboardInterrupt:
        print("\nStopped.")


def cmd_status(args):
    """Show service status from Uptime Kuma."""
    creds = load_credentials()

    uk_url = creds["uptime_kuma"]["url"]

    try:
        # Get public status page data
        resp = requests.get(f"{uk_url}/api/status-page/main", timeout=10)
        resp.raise_for_status()
        data = resp.json()

        # Get heartbeat data for real-time status
        heartbeat_resp = requests.get(f"{uk_url}/api/status-page/heartbeat/main", timeout=10)
        heartbeat_data = heartbeat_resp.json() if heartbeat_resp.ok else {}
        heartbeat_list = heartbeat_data.get("heartbeatList", {})

        monitors = {}
        for group in data.get("publicGroupList", []):
            group_name = group.get("name", "Unknown")
            for mon in group.get("monitorList", []):
                mon_id = str(mon.get("id"))
                mon_name = mon.get("name", "Unknown")

                # Get latest heartbeat
                beats = heartbeat_list.get(mon_id, [])
                if beats:
                    latest = beats[-1]
                    status = latest.get("status", 0)
                    ping = latest.get("ping", "-")
                else:
                    status = 0
                    ping = "-"

                status_str = {0: "DOWN", 1: "UP", 2: "PENDING"}.get(status, "?")
                monitors[mon_name] = {"group": group_name, "status": status_str, "ping": ping}

        if args.service:
            # Filter to specific service
            search = args.service.lower()
            matches = {k: v for k, v in monitors.items() if search in k.lower()}
            if not matches:
                print(f"No monitors found matching '{args.service}'")
                return
            monitors = matches

        # Group by status
        up = [(k, v) for k, v in monitors.items() if v["status"] == "UP"]
        down = [(k, v) for k, v in monitors.items() if v["status"] == "DOWN"]
        pending = [(k, v) for k, v in monitors.items() if v["status"] == "PENDING"]

        if down:
            print("\033[91mDOWN:\033[0m")
            for name, info in sorted(down):
                print(f"  {name} ({info['group']})")

        if pending:
            print("\n\033[93mPENDING:\033[0m")
            for name, info in sorted(pending):
                print(f"  {name} ({info['group']})")

        if args.verbose or args.service:
            print("\n\033[92mUP:\033[0m")
            for name, info in sorted(up):
                ping_str = f" ({info['ping']}ms)" if info['ping'] != "-" else ""
                print(f"  {name}{ping_str}")
        else:
            print(f"\n\033[92mUP:\033[0m {len(up)} monitors")

        # Summary
        total = len(monitors)
        print(f"\nTotal: {total} | UP: {len(up)} | DOWN: {len(down)} | PENDING: {len(pending)}")

    except requests.exceptions.RequestException as e:
        print(f"Error fetching status: {e}")
        sys.exit(1)


def cmd_services(args):
    """List available services/projects."""
    creds = load_credentials()

    print("Available projects in Loki:")
    print("-" * 40)

    projects = get_label_values(creds, "project")
    for p in sorted(projects):
        alias = None
        for k, v in SERVICE_ALIASES.items():
            if v.lower() == p.lower():
                alias = k
                break
        if alias:
            print(f"  {p} (alias: {alias})")
        else:
            print(f"  {p}")

    print("\nService names:")
    print("-" * 40)
    services = get_label_values(creds, "service_name")
    for s in sorted(services):
        print(f"  {s}")

    print("\nAliases:")
    print("-" * 40)
    for alias, project in sorted(SERVICE_ALIASES.items()):
        print(f"  {alias} -> {project}")


def cmd_labels(args):
    """Show available Loki labels and values."""
    creds = load_credentials()

    labels = get_labels(creds)

    for label in labels:
        values = get_label_values(creds, label)
        print(f"\n{label}:")
        for v in sorted(values):
            print(f"  - {v}")


def cmd_query(args):
    """Execute raw LogQL query."""
    creds = load_credentials()

    duration_ns = parse_duration(args.last)
    now = int(datetime.now().timestamp() * 1_000_000_000)
    start_ns = now - duration_ns

    results = query_loki(creds, args.logql, limit=args.limit, start_ns=start_ns, end_ns=now)

    if args.json:
        print(json.dumps(results, indent=2))
    else:
        for stream in results:
            labels = stream.get("stream", {})
            print(f"Stream: {labels}")
            for ts, line in stream.get("values", []):
                dt = datetime.fromtimestamp(int(ts) / 1_000_000_000)
                print(f"  [{dt.strftime('%H:%M:%S')}] {line[:200]}")


def cmd_incidents(args):
    """Show current incidents from Uptime Kuma."""
    creds = load_credentials()
    uk_url = creds["uptime_kuma"]["url"]

    try:
        resp = requests.get(f"{uk_url}/api/status-page/main", timeout=10)
        resp.raise_for_status()
        data = resp.json()

        incident = data.get("incident")
        if incident:
            print(f"\033[91mActive Incident:\033[0m")
            print(f"  Title: {incident.get('title', 'Unknown')}")
            print(f"  Content: {incident.get('content', '')}")
            print(f"  Created: {incident.get('createdDate', '')}")
        else:
            print("\033[92mNo active incidents\033[0m")
    except requests.exceptions.RequestException as e:
        print(f"Error: {e}")
        sys.exit(1)


def main():
    parser = argparse.ArgumentParser(
        description="obs-turbo - Unified observability CLI for abemon.es",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    obs-turbo logs abemon.es --last 1h
    obs-turbo logs abemon.es --error --last 24h
    obs-turbo logs all --grep "500" --last 6h
    obs-turbo tail bm.consulting --filter error
    obs-turbo status
    obs-turbo status abemon
    obs-turbo services
    obs-turbo incidents
"""
    )

    subparsers = parser.add_subparsers(dest="command", help="Commands")

    # logs command
    logs_parser = subparsers.add_parser("logs", help="Query logs from Loki")
    logs_parser.add_argument("service", help="Service name or 'all'")
    logs_parser.add_argument("--last", default="1h", help="Duration (5m, 1h, 24h, 7d)")
    logs_parser.add_argument("--grep", help="Filter by pattern")
    logs_parser.add_argument("--error", action="store_true", help="Show only errors")
    logs_parser.add_argument("--limit", type=int, default=500, help="Max log entries")
    logs_parser.add_argument("--json", action="store_true", help="Output as JSON")
    logs_parser.set_defaults(func=cmd_logs)

    # tail command
    tail_parser = subparsers.add_parser("tail", help="Stream logs in real-time")
    tail_parser.add_argument("service", help="Service name or 'all'")
    tail_parser.add_argument("--filter", help="Filter by pattern")
    tail_parser.set_defaults(func=cmd_tail)

    # status command
    status_parser = subparsers.add_parser("status", help="Show service status")
    status_parser.add_argument("service", nargs="?", help="Filter by service name")
    status_parser.add_argument("-v", "--verbose", action="store_true", help="Show all UP monitors")
    status_parser.set_defaults(func=cmd_status)

    # incidents command
    incidents_parser = subparsers.add_parser("incidents", help="Show current incidents")
    incidents_parser.set_defaults(func=cmd_incidents)

    # services command
    services_parser = subparsers.add_parser("services", help="List available services")
    services_parser.set_defaults(func=cmd_services)

    # labels command
    labels_parser = subparsers.add_parser("labels", help="Show Loki labels")
    labels_parser.set_defaults(func=cmd_labels)

    # query command
    query_parser = subparsers.add_parser("query", help="Execute raw LogQL query")
    query_parser.add_argument("logql", help="LogQL query string")
    query_parser.add_argument("--last", default="1h", help="Duration")
    query_parser.add_argument("--limit", type=int, default=500, help="Max entries")
    query_parser.add_argument("--json", action="store_true", help="Output as JSON")
    query_parser.set_defaults(func=cmd_query)

    args = parser.parse_args()

    if not args.command:
        parser.print_help()
        sys.exit(1)

    try:
        args.func(args)
    except ObsError as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)
    except KeyboardInterrupt:
        sys.exit(0)


if __name__ == "__main__":
    main()
