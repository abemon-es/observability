#!/usr/bin/env zsh
# obs-turbo - Unified observability CLI for abemon.es
# Usage: obs-turbo <command> [options]

set -eo pipefail

# Configuration
CONFIG_FILE="${HOME}/.obs_credentials.json"
GRAFANA_TOKEN=""
UPTIME_KUMA_TOKEN=""
LOKI_URL=""
UPTIME_KUMA_URL=""
GRAFANA_URL=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Service aliases (zsh associative array)
typeset -A SERVICES
SERVICES=(
    abemon "abemon.es"
    bm "bm.consulting"
    codex "codex.abemon.es"
    foodplan "foodplan.pro"
    blue-mountain "blue-mountain.es"
    concursal "concursal.consulting"
    fundacion "dev.fundacionojusa.com"
    logistics "logisticsexpress.es"
)

# Load credentials
load_credentials() {
    if [[ -f "$CONFIG_FILE" ]]; then
        GRAFANA_TOKEN=$(jq -r '.grafana_token // empty' "$CONFIG_FILE" 2>/dev/null || echo "")
        UPTIME_KUMA_TOKEN=$(jq -r '.uptime_kuma_token // empty' "$CONFIG_FILE" 2>/dev/null || echo "")
        LOKI_URL=$(jq -r '.loki_url // empty' "$CONFIG_FILE" 2>/dev/null || echo "")
        UPTIME_KUMA_URL=$(jq -r '.uptime_kuma_url // empty' "$CONFIG_FILE" 2>/dev/null || echo "")
        GRAFANA_URL=$(jq -r '.grafana_url // empty' "$CONFIG_FILE" 2>/dev/null || echo "")
    fi

    # Set defaults if not configured
    LOKI_URL="${LOKI_URL:-https://logs.abemon.es}"
    UPTIME_KUMA_URL="${UPTIME_KUMA_URL:-https://status.abemon.es}"
    GRAFANA_URL="${GRAFANA_URL:-https://logs.abemon.es}"
}

# Print usage
usage() {
    echo -e "${BLUE}obs-turbo${NC} - Unified observability CLI for abemon.es"
    echo ""
    echo -e "${YELLOW}USAGE:${NC}"
    echo "    obs-turbo <command> [service] [options]"
    echo ""
    echo -e "${YELLOW}COMMANDS:${NC}"
    echo -e "    ${GREEN}logs${NC} <service>     Query logs from Loki"
    echo -e "    ${GREEN}tail${NC} <service>     Stream logs in real-time"
    echo -e "    ${GREEN}status${NC} [service]   Check service status from Uptime Kuma"
    echo -e "    ${GREEN}incidents${NC}          List current incidents"
    echo -e "    ${GREEN}metrics${NC} <service>  Show service metrics"
    echo -e "    ${GREEN}services${NC}           List all monitored services"
    echo -e "    ${GREEN}config${NC}             Show/edit configuration"
    echo ""
    echo -e "${YELLOW}SERVICES:${NC}"
    echo "    abemon, bm, codex, foodplan, blue-mountain, concursal, fundacion, logistics"
    echo "    Or use 'all' for all services"
    echo ""
    echo -e "${YELLOW}OPTIONS:${NC}"
    echo "    --last <duration>    Time range (e.g., 1h, 24h, 7d) [default: 1h]"
    echo "    --error              Only show errors"
    echo "    --grep <pattern>     Filter by pattern"
    echo "    --format <type>      Output format: text, json [default: text]"
    echo "    --limit <n>          Max number of results [default: 100]"
    echo ""
    echo -e "${YELLOW}EXAMPLES:${NC}"
    echo "    obs-turbo logs abemon --last 1h"
    echo "    obs-turbo logs abemon --error --last 24h"
    echo "    obs-turbo logs all --grep \"500\" --last 6h"
    echo "    obs-turbo tail abemon"
    echo "    obs-turbo status"
    echo "    obs-turbo incidents"
    echo ""
}

# Resolve service name
resolve_service() {
    local service="$1"
    if [[ "$service" == "all" ]]; then
        echo ""
    elif [[ -n "${SERVICES[$service]}" ]]; then
        echo "${SERVICES[$service]}"
    else
        echo "$service"
    fi
}

# Query logs using logcli
cmd_logs() {
    # Handle --help as first argument
    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        echo -e "${BLUE}obs-turbo logs${NC} - Query logs from Loki"
        echo ""
        echo -e "${YELLOW}USAGE:${NC}"
        echo "    obs-turbo logs <service> [options]"
        echo ""
        echo -e "${YELLOW}ARGUMENTS:${NC}"
        echo "    <service>            Service name (abemon, bm, codex, etc.) or 'all'"
        echo ""
        echo -e "${YELLOW}OPTIONS:${NC}"
        echo "    --last <duration>    Time range (e.g., 1h, 24h, 7d) [default: 1h]"
        echo "    --error              Only show errors"
        echo "    --grep <pattern>     Filter by pattern"
        echo "    --format <type>      Output format: text, json [default: text]"
        echo "    --limit <n>          Max number of results [default: 100]"
        echo ""
        echo -e "${YELLOW}EXAMPLES:${NC}"
        echo "    obs-turbo logs abemon --last 1h"
        echo "    obs-turbo logs abemon --error --last 24h"
        echo "    obs-turbo logs all --grep \"500\" --last 6h"
        echo ""
        echo -e "${YELLOW}REQUIRES:${NC}"
        echo "    logcli - Install with: brew install loki"
        echo ""
        return 0
    fi

    local service="${1:-all}"
    shift || true

    local duration="1h"
    local only_errors=false
    local grep_pattern=""
    local format="text"
    local limit=100

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --last)
                duration="$2"
                shift 2
                ;;
            --error)
                only_errors=true
                shift
                ;;
            --grep)
                grep_pattern="$2"
                shift 2
                ;;
            --format)
                format="$2"
                shift 2
                ;;
            --limit)
                limit="$2"
                shift 2
                ;;
            -h|--help)
                # Already handled above, but in case it appears after service name
                cmd_logs --help
                return 0
                ;;
            *)
                shift
                ;;
        esac
    done

    local resolved_service=$(resolve_service "$service")
    local query=""

    if [[ -n "$resolved_service" ]]; then
        query="{service=\"$resolved_service\"}"
    else
        query="{source=\"railway\"}"
    fi

    if [[ "$only_errors" == true ]]; then
        query="$query |~ \`(?i)(error|fail|exception|critical)\`"
    fi

    if [[ -n "$grep_pattern" ]]; then
        query="$query |~ \`$grep_pattern\`"
    fi

    echo -e "${BLUE}Querying logs...${NC}"
    echo -e "${YELLOW}Query:${NC} $query"
    echo -e "${YELLOW}Range:${NC} last $duration"
    echo ""

    if command -v logcli &> /dev/null; then
        logcli query \
            --addr="$LOKI_URL" \
            --since="$duration" \
            --limit="$limit" \
            --output="$format" \
            "$query"
    else
        echo -e "${RED}Error: logcli not installed${NC}"
        echo "Install with: brew install loki"
        exit 1
    fi
}

# Stream logs in real-time
cmd_tail() {
    local service="${1:-all}"
    shift || true

    local filter=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --filter)
                filter="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    local resolved_service=$(resolve_service "$service")
    local query=""

    if [[ -n "$resolved_service" ]]; then
        query="{service=\"$resolved_service\"}"
    else
        query="{source=\"railway\"}"
    fi

    if [[ -n "$filter" ]]; then
        query="$query |~ \`(?i)$filter\`"
    fi

    echo -e "${BLUE}Streaming logs...${NC} (Ctrl+C to stop)"
    echo -e "${YELLOW}Query:${NC} $query"
    echo ""

    if command -v logcli &> /dev/null; then
        logcli query \
            --addr="$LOKI_URL" \
            --tail \
            --output=default \
            "$query"
    else
        echo -e "${RED}Error: logcli not installed${NC}"
        echo "Install with: brew install loki"
        exit 1
    fi
}

# Check status from Uptime Kuma
cmd_status() {
    local service="${1:-}"

    echo -e "${BLUE}Checking service status...${NC}"
    echo ""

    # Use Uptime Kuma API - need two endpoints
    local main_url="$UPTIME_KUMA_URL/api/status-page/main"
    local heartbeat_url="$UPTIME_KUMA_URL/api/status-page/heartbeat/main"

    if command -v curl &> /dev/null; then
        local main_response=$(curl -s "$main_url" 2>/dev/null || echo '{"error": "Failed to fetch"}')
        local heartbeat_response=$(curl -s "$heartbeat_url" 2>/dev/null || echo '{"heartbeatList": {}}')

        if printf '%s' "$main_response" | jq -e '.error' &>/dev/null; then
            echo -e "${YELLOW}Unable to fetch from Uptime Kuma API${NC}"
            echo "Falling back to direct HTTP checks..."
            echo ""

            # Direct HTTP checks
            for svc_alias in ${(k)SERVICES}; do
                local url="${SERVICES[$svc_alias]}"
                if [[ -z "$service" || "$svc_alias" == "$service" ]]; then
                    local status_code=$(curl -s -o /dev/null -w "%{http_code}" "https://$url" --max-time 5 2>/dev/null || echo "000")
                    if [[ "$status_code" == "200" ]]; then
                        echo -e "${GREEN}[UP]${NC} $svc_alias ($url) - HTTP $status_code"
                    else
                        echo -e "${RED}[DOWN]${NC} $svc_alias ($url) - HTTP $status_code"
                    fi
                fi
            done
        else
            # Parse monitors and heartbeats together (use printf to avoid escape sequence interpretation)
            local monitors=$(printf '%s' "$main_response" | jq -r '.publicGroupList[]?.monitorList[]? | "\(.id)|\(.name)"' 2>/dev/null)

            if [[ -z "$monitors" ]]; then
                echo "No monitors found"
                return 0
            fi

            # Display header
            printf "%-25s %-10s %-10s\n" "SERVICE" "STATUS" "PING"
            echo "-------------------------------------------"

            # Process each monitor
            while IFS='|' read -r monitor_id monitor_name; do
                [[ -z "$monitor_id" ]] && continue

                # Filter by service if specified
                if [[ -n "$service" ]]; then
                    local service_domain=$(resolve_service "$service")
                    if [[ "$monitor_name" != *"$service"* && "$monitor_name" != *"$service_domain"* ]]; then
                        continue
                    fi
                fi

                # Get latest heartbeat for this monitor
                local latest_heartbeat=$(printf '%s' "$heartbeat_response" | jq -r ".heartbeatList[\"$monitor_id\"][-1]" 2>/dev/null)
                local monitor_status=$(printf '%s' "$latest_heartbeat" | jq -r '.status // 0' 2>/dev/null)
                local ping_time=$(printf '%s' "$latest_heartbeat" | jq -r '.ping // "-"' 2>/dev/null)

                if [[ "$monitor_status" == "1" ]]; then
                    printf "${GREEN}%-25s${NC} ${GREEN}%-10s${NC} %s ms\n" "$monitor_name" "UP" "$ping_time"
                else
                    printf "${RED}%-25s${NC} ${RED}%-10s${NC} %s ms\n" "$monitor_name" "DOWN" "$ping_time"
                fi
            done <<< "$monitors"
        fi
    else
        echo -e "${RED}Error: curl not installed${NC}"
        exit 1
    fi
}

# List incidents
cmd_incidents() {
    echo -e "${BLUE}Checking for incidents...${NC}"
    echo ""

    local api_url="$UPTIME_KUMA_URL/api/status-page/main"

    if command -v curl &> /dev/null; then
        local response=$(curl -s "$api_url" 2>/dev/null || echo '{}')
        local incidents=$(echo "$response" | jq -r '.incident // empty' 2>/dev/null)

        if [[ -n "$incidents" && "$incidents" != "null" ]]; then
            echo -e "${RED}Active Incidents:${NC}"
            echo "$incidents" | jq -r '.title // "Unknown incident"'
        else
            echo -e "${GREEN}No active incidents${NC}"
        fi
    else
        echo -e "${RED}Error: curl not installed${NC}"
        exit 1
    fi
}

# Show metrics
cmd_metrics() {
    local service="${1:-all}"
    local format="${2:-text}"

    echo -e "${BLUE}Fetching metrics...${NC}"
    echo ""

    # Query Prometheus via Grafana API or directly
    local resolved_service=$(resolve_service "$service")

    if [[ -n "$GRAFANA_TOKEN" ]]; then
        # Use Grafana API
        curl -s -H "Authorization: Bearer $GRAFANA_TOKEN" \
            "$GRAFANA_URL/api/datasources/proxy/1/api/v1/query?query=up" 2>/dev/null | \
            jq -r '.data.result[] | "\(.metric.job): \(.value[1])"' 2>/dev/null || \
            echo "Failed to fetch metrics"
    else
        echo -e "${YELLOW}Grafana token not configured${NC}"
        echo "Add grafana_token to ~/.obs_credentials.json"
    fi
}

# List services
cmd_services() {
    echo -e "${BLUE}Monitored Services:${NC}"
    echo ""

    echo -e "${YELLOW}Railway:${NC}"
    for svc in abemon bm codex foodplan; do
        echo "  $svc -> ${SERVICES[$svc]}"
    done

    echo ""
    echo -e "${YELLOW}Hostinger:${NC}"
    for svc in blue-mountain concursal fundacion logistics; do
        echo "  $svc -> ${SERVICES[$svc]}"
    done
}

# Show/edit config
cmd_config() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo -e "${YELLOW}Creating config file...${NC}"
        cat > "$CONFIG_FILE" << 'EOF'
{
  "loki_url": "https://logs.abemon.es",
  "uptime_kuma_url": "https://status.abemon.es",
  "grafana_url": "https://logs.abemon.es",
  "grafana_token": "",
  "uptime_kuma_token": ""
}
EOF
        echo "Created: $CONFIG_FILE"
    fi

    echo -e "${BLUE}Configuration:${NC}"
    cat "$CONFIG_FILE" | jq .
    echo ""
    echo "Edit with: ${YELLOW}\$EDITOR $CONFIG_FILE${NC}"
}

# Main
main() {
    load_credentials

    local command="${1:-help}"
    shift || true

    case "$command" in
        logs)
            cmd_logs "$@"
            ;;
        tail)
            cmd_tail "$@"
            ;;
        status)
            cmd_status "$@"
            ;;
        incidents)
            cmd_incidents
            ;;
        metrics)
            cmd_metrics "$@"
            ;;
        services)
            cmd_services
            ;;
        config)
            cmd_config
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            echo -e "${RED}Unknown command: $command${NC}"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
